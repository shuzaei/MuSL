<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MuSL Simulation Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .chart-container {
            width: 100%;
            margin-bottom: 30px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
        }

        .chart-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-box {
            flex: 1;
            min-width: 45%;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }

        .loading {
            text-align: center;
            margin: 50px 0;
            font-size: 18px;
        }

        #file-input {
            margin: 20px auto;
            display: block;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>MuSL Simulation Visualizer</h1>

        <div class="controls">
            <input type="file" id="file-input" accept=".json">
            <button id="load-default">Load Default Data</button>
        </div>

        <div id="loading" class="loading" style="display: none;">Loading data...</div>

        <div id="charts-container" style="display: none;">
            <div class="chart-row">
                <div class="chart-box">
                    <h3>Population Over Time</h3>
                    <canvas id="populationChart"></canvas>
                </div>
                <div class="chart-box">
                    <h3>Energy Distribution</h3>
                    <canvas id="energyChart"></canvas>
                </div>
            </div>

            <div class="chart-row">
                <div class="chart-box">
                    <h3>Deaths and Reproductions</h3>
                    <canvas id="demographicsChart"></canvas>
                </div>
                <div class="chart-box">
                    <h3>Population Dynamics</h3>
                    <canvas id="populationDynamicsChart"></canvas>
                </div>
            </div>

            <div class="chart-row">
                <div class="chart-box">
                    <h3>Songs and Evaluations</h3>
                    <canvas id="songsChart"></canvas>
                </div>
                <div class="chart-box">
                    <h3>Events Over Time</h3>
                    <canvas id="eventsChart"></canvas>
                </div>
            </div>

            <div class="chart-row">
                <div class="chart-box">
                    <h3>Average Innovation & Novelty Preference</h3>
                    <canvas id="innovationChart"></canvas>
                </div>
                <div class="chart-box">
                    <h3>Evaluation Metrics</h3>
                    <canvas id="evaluationChart"></canvas>
                </div>
            </div>

            <div class="chart-row">
                <div class="chart-box">
                    <h3>Genre Distribution (Last Iteration)</h3>
                    <canvas id="genreScatterChart"></canvas>
                </div>
                <div class="chart-box">
                    <h3>Population Growth Rate</h3>
                    <canvas id="populationGrowthChart"></canvas>
                </div>
            </div>

            <div class="chart-row">
                <div class="chart-box">
                    <h3>Energy Efficiency Index</h3>
                    <canvas id="energyEfficiencyChart"></canvas>
                </div>
                <div class="chart-box">
                    <h3>Hardiness Analysis</h3>
                    <canvas id="hardinessChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let simulationData = [];
        let charts = {};

        // Event listeners
        document.getElementById('file-input').addEventListener('change', handleFileUpload);
        document.getElementById('load-default').addEventListener('click', loadDefaultData);

        // Load default data from output.json
        function loadDefaultData() {
            showLoading();
            fetch('output.json')
                .then(response => response.json())
                .then(data => {
                    simulationData = data;
                    processData();
                })
                .catch(error => {
                    console.error('Error loading default data:', error);
                    alert('Failed to load default data. Please check console for errors.');
                    hideLoading();
                });
        }

        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoading();
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    simulationData = JSON.parse(e.target.result);
                    processData();
                } catch (error) {
                    console.error('Error parsing JSON:', error);
                    alert('Failed to parse JSON file. Please check console for errors.');
                    hideLoading();
                }
            };
            reader.readAsText(file);
        }

        // Process data and create charts
        function processData() {
            // Show charts container
            document.getElementById('charts-container').style.display = 'block';

            // Create or update charts
            createPopulationChart();
            createEnergyChart();
            createSongsChart();
            createEventsChart();
            createInnovationChart();
            createEvaluationChart();
            createDemographicsChart();
            createPopulationDynamicsChart();
            createGenreScatterChart();
            createPopulationGrowthChart();
            createEnergyEfficiencyChart();
            createHardinessChart();

            hideLoading();
        }

        // Create population chart
        function createPopulationChart() {
            const ctx = document.getElementById('populationChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const totalPopulation = simulationData.map(data => data.num_population);
            const creaters = simulationData.map(data => data.num_creaters);
            const listeners = simulationData.map(data => data.num_listeners);
            const organizers = simulationData.map(data => data.num_organizers);

            if (charts.populationChart) {
                charts.populationChart.destroy();
            }

            charts.populationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Total Population',
                            data: totalPopulation,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Creators',
                            data: creaters,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Listeners',
                            data: listeners,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Organizers',
                            data: organizers,
                            borderColor: 'rgba(255, 206, 86, 1)',
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Population Changes Over Iterations'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Create energy distribution chart
        function createEnergyChart() {
            const ctx = document.getElementById('energyChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const totalEnergy = simulationData.map(data => data.total_energy);
            const creatorEnergy = simulationData.map(data => data.energy_creators);
            const listenerEnergy = simulationData.map(data => data.energy_listeners);
            const organizerEnergy = simulationData.map(data => data.energy_organizers);

            if (charts.energyChart) {
                charts.energyChart.destroy();
            }

            charts.energyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Total Energy',
                            data: totalEnergy,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Creator Energy',
                            data: creatorEnergy,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Listener Energy',
                            data: listenerEnergy,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Organizer Energy',
                            data: organizerEnergy,
                            borderColor: 'rgba(255, 206, 86, 1)',
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Energy Distribution Over Iterations'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Energy'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Create songs and evaluations chart
        function createSongsChart() {
            const ctx = document.getElementById('songsChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const songAll = simulationData.map(data => data.num_song_all);
            const songThis = simulationData.map(data => data.num_song_this);
            const songNow = simulationData.map(data => data.num_song_now);

            if (charts.songsChart) {
                charts.songsChart.destroy();
            }

            charts.songsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Total Songs Created',
                            data: songAll,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Songs Created This Iteration',
                            data: songThis,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Current Songs',
                            data: songNow,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Songs Over Iterations'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Create events chart
        function createEventsChart() {
            const ctx = document.getElementById('eventsChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const eventAll = simulationData.map(data => data.num_event_all);
            const eventThis = simulationData.map(data => data.num_event_this);

            if (charts.eventsChart) {
                charts.eventsChart.destroy();
            }

            charts.eventsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Total Events',
                            data: eventAll,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Events This Iteration',
                            data: eventThis,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Events Over Iterations'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Create innovation chart
        function createInnovationChart() {
            const ctx = document.getElementById('innovationChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const innovation = simulationData.map(data => data.avg_innovation);
            const noveltyPreference = simulationData.map(data => data.avg_novelty_preference);

            if (charts.innovationChart) {
                charts.innovationChart.destroy();
            }

            charts.innovationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Average Innovation',
                            data: innovation,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Average Novelty Preference',
                            data: noveltyPreference,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Innovation and Novelty Preference'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Value'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Create evaluation chart
        function createEvaluationChart() {
            const ctx = document.getElementById('evaluationChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const avgEvaluation = simulationData.map(data => data.avg_evaluation);
            const evaluationAll = simulationData.map(data => data.num_evaluation_all);
            const evaluationThis = simulationData.map(data => data.num_evaluation_this);

            if (charts.evaluationChart) {
                charts.evaluationChart.destroy();
            }

            charts.evaluationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Average Evaluation',
                            data: avgEvaluation,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Total Evaluations',
                            data: evaluationAll,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Evaluations This Iteration',
                            data: evaluationThis,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Evaluation Metrics'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Average Value'
                            },
                            beginAtZero: true
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }

        // Create demographics chart (deaths and reproductions)
        function createDemographicsChart() {
            const ctx = document.getElementById('demographicsChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const deaths = simulationData.map(data => data.num_deaths || 0);
            const reproductions = simulationData.map(data => data.num_reproductions || 0);

            // Calculate cumulative values
            const cumulativeDeaths = deaths.reduce((acc, val, idx) => {
                if (idx === 0) return [val];
                return [...acc, acc[idx - 1] + val];
            }, []);

            const cumulativeReproductions = reproductions.reduce((acc, val, idx) => {
                if (idx === 0) return [val];
                return [...acc, acc[idx - 1] + val];
            }, []);

            if (charts.demographicsChart) {
                charts.demographicsChart.destroy();
            }

            charts.demographicsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Deaths per Iteration',
                            data: deaths,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Reproductions per Iteration',
                            data: reproductions,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Cumulative Deaths',
                            data: cumulativeDeaths,
                            borderColor: 'rgba(128, 0, 0, 1)',
                            backgroundColor: 'rgba(128, 0, 0, 0.1)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Cumulative Reproductions',
                            data: cumulativeReproductions,
                            borderColor: 'rgba(0, 0, 128, 1)',
                            backgroundColor: 'rgba(0, 0, 128, 0.1)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Deaths and Reproductions Over Time'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Count per Iteration'
                            },
                            beginAtZero: true
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Cumulative Count'
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }

        // Create population dynamics chart
        function createPopulationDynamicsChart() {
            const ctx = document.getElementById('populationDynamicsChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const population = simulationData.map(data => data.num_population);
            const deaths = simulationData.map(data => data.num_deaths || 0);
            const reproductions = simulationData.map(data => data.num_reproductions || 0);

            // Calculate net population change
            const netChange = population.map((pop, idx) => {
                if (idx === 0) return pop;
                return reproductions[idx] - deaths[idx];
            });

            if (charts.populationDynamicsChart) {
                charts.populationDynamicsChart.destroy();
            }

            charts.populationDynamicsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Deaths',
                            data: deaths.map(v => -v), // Negative values for deaths
                            backgroundColor: 'rgba(255, 99, 132, 0.7)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Reproductions',
                            data: reproductions,
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Population Changes by Iteration'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            },
                            stacked: true
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            stacked: true
                        }
                    }
                }
            });
        }

        // Create genre scatter chart
        function createGenreScatterChart() {
            const ctx = document.getElementById('genreScatterChart').getContext('2d');

            // Get the last iteration data
            const lastIterationData = simulationData[simulationData.length - 1];

            // Check if all_genres exists in the data
            if (!lastIterationData || !lastIterationData.all_genres || !Array.isArray(lastIterationData.all_genres)) {
                console.warn('No genre data available for scatter plot');
                return;
            }

            // Get the genre data points
            const genrePoints = lastIterationData.all_genres.map(genreInfo => {
                return {
                    x: genreInfo.genre[0],  // First dimension of genre
                    y: genreInfo.genre[1],  // Second dimension of genre
                    id: genreInfo.id        // Song ID for tooltip
                };
            });

            if (charts.genreScatterChart) {
                charts.genreScatterChart.destroy();
            }

            charts.genreScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Genres',
                            data: genrePoints,
                            backgroundColor: function (context) {
                                // Color based on song ID to represent age
                                const index = context.dataIndex;
                                const id = genrePoints[index].id;
                                const maxId = Math.max(...genrePoints.map(p => p.id));
                                const minId = Math.min(...genrePoints.map(p => p.id));
                                const normalizedId = (id - minId) / (maxId - minId || 1);

                                // Create color gradient from blue (older) to red (newer)
                                const r = Math.floor(normalizedId * 255);
                                const b = Math.floor((1 - normalizedId) * 255);
                                return `rgba(${r}, 100, ${b}, 0.7)`;
                            },
                            pointRadius: 5,
                            pointHoverRadius: 7
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Genre Space Distribution (Last Iteration)'
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const point = genrePoints[context.dataIndex];
                                    return `Song ID: ${point.id}, Genre: [${point.x.toFixed(2)}, ${point.y.toFixed(2)}]`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Genre Dimension 1'
                            },
                            min: 0,
                            max: 1
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Genre Dimension 2'
                            },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        // Create population growth chart
        function createPopulationGrowthChart() {
            const ctx = document.getElementById('populationGrowthChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const population = simulationData.map(data => data.num_population);
            const growthRates = population.map((pop, idx) => {
                if (idx === 0) return 0;
                return (pop - population[idx - 1]) / population[idx - 1];
            });

            if (charts.populationGrowthChart) {
                charts.populationGrowthChart.destroy();
            }

            charts.populationGrowthChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Population Growth Rate',
                            data: growthRates,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Population Growth Rate Over Iterations'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Growth Rate'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Create energy efficiency chart
        function createEnergyEfficiencyChart() {
            const ctx = document.getElementById('energyEfficiencyChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const totalEnergy = simulationData.map(data => data.total_energy);
            const population = simulationData.map(data => data.num_population);
            const songsCreated = simulationData.map(data => data.num_song_this);

            // Calculate energy efficiency (energy per capita)
            const energyPerCapita = totalEnergy.map((energy, idx) => {
                if (population[idx] === 0) return 0;
                return energy / population[idx];
            });

            // Calculate creative efficiency (songs per energy unit)
            const creativeEfficiency = songsCreated.map((songs, idx) => {
                if (totalEnergy[idx] === 0) return 0;
                return songs / totalEnergy[idx] * 100; // Scale for better visualization
            });

            if (charts.energyEfficiencyChart) {
                charts.energyEfficiencyChart.destroy();
            }

            charts.energyEfficiencyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'Energy per Capita',
                            data: energyPerCapita,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Creative Efficiency (x100)',
                            data: creativeEfficiency,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'System Efficiency Metrics'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Energy per Capita'
                            },
                            beginAtZero: true
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Creative Efficiency Index'
                            },
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }

        // Create hardiness chart
        function createHardinessChart() {
            const ctx = document.getElementById('hardinessChart').getContext('2d');

            const iterations = simulationData.map((_, index) => index);
            const population = simulationData.map(data => data.num_population);
            const deaths = simulationData.map(data => data.num_deaths || 0);
            const reproductions = simulationData.map(data => data.num_reproductions || 0);

            // Calculate population stability (inverse of population change rate)
            const populationStability = population.map((pop, idx) => {
                if (idx === 0) return 1.0;
                const changeRate = Math.abs(pop - population[idx - 1]) / population[idx - 1];
                return 1.0 / (changeRate + 0.01); // Inverse of change rate, avoid division by zero
            });

            // Normalize to 0-1 range
            const normalizeArray = (arr) => {
                const max = Math.max(...arr);
                const min = Math.min(...arr);
                return arr.map(val => (val - min) / (max - min) || 0);
            };

            const normalizedStability = normalizeArray(populationStability);

            // Calculate sustainability index (ratio of births to deaths)
            const sustainabilityIndex = deaths.map((death, idx) => {
                if (death === 0) return 1.0; // Perfect sustainability if no deaths
                return reproductions[idx] / death; // Ratio of births to deaths
            });

            // Cap sustainability for better visualization
            const cappedSustainability = sustainabilityIndex.map(val =>
                Math.min(val, 2.0) // Cap at 2.0 for better visualization
            );

            // Calculate diversity index (using population + innovative rate where available)
            const diversity = simulationData.map((data, idx) => {
                const basePopulation = Math.min(data.num_population / 100, 1.0); // Normalize
                const innovation = data.avg_innovation || 0.5;
                return (basePopulation * 0.5) + (innovation * 0.5); // Weighted average
            });

            // Calculate composite hardiness (weighted average of all factors)
            const hardiness = normalizedStability.map((stability, idx) => {
                return (
                    stability * 0.4 +
                    Math.min(cappedSustainability[idx] / 2, 1.0) * 0.4 +
                    diversity[idx] * 0.2
                );
            });

            if (charts.hardinessChart) {
                charts.hardinessChart.destroy();
            }

            charts.hardinessChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: iterations,
                    datasets: [
                        {
                            label: 'System Hardiness Index',
                            data: hardiness,
                            borderColor: 'rgba(153, 102, 255, 1)',
                            backgroundColor: 'rgba(153, 102, 255, 0.2)',
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Population Stability',
                            data: normalizedStability,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false
                        },
                        {
                            label: 'Sustainability',
                            data: cappedSustainability.map(v => v / 2), // Scale to 0-1 range
                            borderColor: 'rgba(255, 159, 64, 1)',
                            backgroundColor: 'rgba(255, 159, 64, 0.2)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false
                        },
                        {
                            label: 'Diversity',
                            data: diversity,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'System Hardiness Analysis'
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const value = context.raw;
                                    const dataset = context.dataset.label;
                                    if (dataset === 'Sustainability') {
                                        return `${dataset}: ${(value * 2).toFixed(2)}`;
                                    }
                                    return `${dataset}: ${value.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Index Value (0-1)'
                            },
                            beginAtZero: true,
                            max: 1.0
                        }
                    }
                }
            });
        }

        // Show loading indicator
        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('charts-container').style.display = 'none';
        }

        // Hide loading indicator
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Initial load - check if output.json exists and load it
        window.addEventListener('DOMContentLoaded', () => {
            loadDefaultData();
        });
    </script>
</body>

</html>